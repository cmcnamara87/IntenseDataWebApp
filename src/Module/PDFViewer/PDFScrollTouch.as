package Module.PDFViewer  {		import flash.display.Sprite;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.geom.Point;	import flash.utils.Timer;		public class PDFScrollTouch extends Sprite {				private var scrollArea:PDFScrollArea;		private var containerWidth:Number;		private var containerHeight:Number;		private var touchTimer:Timer = new Timer(30);				private var bounds:Object = {top:0,bottom:0,left:0,right:0};				private var currentX:Number = 0;		private var lastX:Number = 0;		private var vx:Number = 0;				private var currentY:Number = 0;		private var lastY:Number = 0;		private var vy:Number = 0;				private var scrollingSet:Boolean = false;				private var accelleration:Number = 0.95;				private var scrollType:String = '';		private var showScrollbars:Boolean = true;		private var touchscrolling:Boolean = false;				private var scrollTearX:Sprite = new Sprite();		private var scrollTearY:Sprite = new Sprite();				public function PDFScrollTouch(scrollArea:PDFScrollArea,containerWidth:Number,containerHeight:Number,scrollType:String = '',showScrollbars:Boolean = true) {			this.buttonMode = true;			this.useHandCursor = true;			this.accelleration = scrollArea.accelleration;			this.showScrollbars = showScrollbars;			this.scrollType = scrollType;			this.scrollArea = scrollArea;			this.containerWidth = containerWidth;			this.containerHeight = containerHeight;			this.graphics.beginFill(0xFF0000,0.000001);			this.graphics.drawRect(0,0,containerWidth,containerHeight);			scrollArea.addChild(this);			setBounds();			if(!showScrollbars) {				setupTouchTears();			}			this.addEventListener(MouseEvent.MOUSE_DOWN,startTouch);			touchTimer.addEventListener(TimerEvent.TIMER,touchMove);			this.addEventListener(MouseEvent.MOUSE_UP,stopTouch);			this.addEventListener(MouseEvent.MOUSE_OUT,stopTouch);			this.addEventListener(MouseEvent.MOUSE_WHEEL,scrollWindow);		}				private function scrollWindow(e:MouseEvent):void {			vy = e.delta*6;			moveInner();		}				private function setupTouchTears():void {			if(scrollType != 'y') {				scrollTearX.graphics.beginFill(0x333333,0.5);				scrollTearX.graphics.drawRoundRect(0,0,100,10,10);				scrollTearX.y = containerHeight - 20;				scrollTearX.x = 10;				addChild(scrollTearX);				scrollTearX.alpha = 0;			}			if(scrollType != 'x') {				scrollTearY.graphics.beginFill(0x333333,0.5);				scrollTearY.graphics.drawRoundRect(0,0,10,100,10);				scrollTearY.x = containerWidth - 20;				addChild(scrollTearY);				scrollTearY.y = 10;				scrollTearY.alpha = 0;			}		}				private function setBounds():void {			bounds.left = Math.round(0);			bounds.right = Math.round(scrollArea.innerObject.width - containerWidth);			bounds.top = Math.round(0);			bounds.bottom = Math.round(scrollArea.innerObject.height - containerHeight);		}				private function startTouch(e:MouseEvent):void {			if(vx == 0 && vy == 0) {				scrollingSet = false;			} else {				scrollingSet = true;			}			touchscrolling = true;			touchTimer.start();			lastX = mouseX;			currentX = mouseX;			lastY = mouseY;			currentY = mouseY;		}				private function moveInner():void {			if(scrollType != 'y') {				if(vx > 1 && scrollArea.innerObject.x + vx >= bounds.left*-1) {					scrollArea.innerObject.x = bounds.left * -1;					if(scrollArea.useBounceBack) {						vx *= scrollArea.reverseAmount;					} else {						vx = 0;					}				} else if(vx < 1 && scrollArea.innerObject.x + vx <= bounds.right*-1) {					scrollArea.innerObject.x = bounds.right * -1;					if(scrollArea.useBounceBack) {						vx *= scrollArea.reverseAmount;					} else {						vx = 0;					}				} else {					scrollArea.innerObject.x += vx;				}				if(showScrollbars) {					scrollArea.updateScrollbarX();				} else {					scrollTearX.x = (containerWidth-scrollTearX.width-20)*(scrollArea.innerObject.x*-1/(scrollArea.width-containerWidth))+10;					scrollTearX.alpha = 1;				}			}			if(scrollType != 'x') {				if(vy > 1 && scrollArea.innerObject.y + vy >= bounds.top*-1) {					scrollArea.innerObject.y = bounds.top * -1;					if(scrollArea.useBounceBack) {						vy *= scrollArea.reverseAmount;					} else {						vy = 0;					}				} else if(vy < 1 && scrollArea.innerObject.y + vy <= bounds.bottom*-1) {					scrollArea.innerObject.y = bounds.bottom * -1;					if(scrollArea.useBounceBack) {						vy *= scrollArea.reverseAmount;					} else {						vy = 0;					}				} else {					scrollArea.innerObject.y += vy;				}				if(showScrollbars) {					scrollArea.updateScrollbarY();				} else {					scrollTearY.y = (containerHeight-scrollTearY.height-20)*(scrollArea.innerObject.y*-1/(scrollArea.height-containerHeight))+10;					scrollTearY.alpha = 1;				}			}		}				private function touchMove(e:TimerEvent):void {			if(touchscrolling) {				lastX = currentX;				currentX = mouseX;				vx = currentX - lastX;				if(vx != 0 && !scrollingSet) {					scrollingSet = true;				}				/* Y POSITION */				lastY = currentY;				currentY = mouseY;				vy = currentY - lastY;				if(vy != 0 && !scrollingSet) {					scrollingSet = true;				}				moveInner();			} else {				if(scrollArea.useFriction) {					if(Math.abs(vx) > 0.1) {						vx *= accelleration;					} else {						vx = 0;					}					if(Math.abs(vy) > 0.1) {						vy *= accelleration;					} else {						vy = 0;					}					if(vx == 0 && vy == 0) {						touchTimer.stop();						scrollTearX.alpha = 0;						scrollTearY.alpha = 0;					} else {						moveInner();					}				} else {					touchTimer.stop();					scrollTearX.alpha = 0;					scrollTearY.alpha = 0;				}			}		}				private function stopTouch(e:MouseEvent):void {			//If the gesture was a click, rather than a scroll or a mouse_out			if(!scrollingSet) {				clickInner(e);			}						touchscrolling = false;		}				private function clickInner(e:MouseEvent):void {			if(e.type == 'mouseUp') {				e.stopImmediatePropagation();				var globalpoints:Point = localToGlobal(new Point(e.localX,e.localY));				this.parent.mouseEnabled = false;				scrollArea.removeChild(this);				var objects:Array = scrollArea.stage.getObjectsUnderPoint(globalpoints);				var theObject:* = objects[objects.length-1];				scrollArea.addChild(this);				try {					//this.stage.focus = theObject;					theObject.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_UP, true, false));					theObject.dispatchEvent(new MouseEvent(MouseEvent.CLICK, true, false));					this.parent.mouseEnabled = true;				} catch (e:Error) {					try {						this.stage.focus = theObject.parent;						theObject.parent.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_UP, true, false));						theObject.parent.dispatchEvent(new MouseEvent(MouseEvent.CLICK, true, false));						this.parent.parent.mouseEnabled = true;						trace("Bad conversion");					} catch (e:Error) {}				}			}		}			}	}