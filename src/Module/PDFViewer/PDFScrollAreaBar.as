package Module.PDFViewer  {		import flash.display.GradientType;	import flash.display.SpreadMethod;	import flash.display.Sprite;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.filters.GlowFilter;	import flash.geom.Matrix;	import flash.utils.Timer;		import mx.managers.CursorManager;		public class PDFScrollAreaBar extends Sprite {				private var scrollType:String;		private var scrollbarWidth:Number;				private var colourArray:Array;				private var bounds:Object = {top:0,bottom:0,left:0,right:0};				private var scrollingTear:Boolean = false;				private var scrollSpeed:Number = 30;				private var moveArray:Array = new Array(0,0);				private var containerWidth:Number;		private var containerHeight:Number;				private var buttonPressTimer:Timer = new Timer(30);		private var buttonPressMovement:Number = 0;				private var tearDragTimer:Timer = new Timer(10);		private var tearScrolling:Boolean = false;				private var tearPastX:Number = 0;		private var tearCurrentX:Number = 0;		private var vx:Number = 0;		private var tearPastY:Number = 0;		private var tearCurrentY:Number = 0;		private var vy:Number = 0;		private var accelleration:Number = 0.95;						private var backButton:Sprite = new Sprite();		private var forwardButton:Sprite = new Sprite();		private var scrollTear:Sprite = new Sprite();		private var tearLength:Number = 30;				private var buttonGlowFilter:GlowFilter;		private var buttonFilters:Array = new Array();				private var scrollArea:PDFScrollArea;				private var scrollLeft:Sprite = new Sprite();		private var scrollRight:Sprite = new Sprite();				private var scrollbarXbg:Sprite = new Sprite();		private var scrollbarYbg:Sprite = new Sprite();				private var curvedMaskV:Sprite = new Sprite();		private var curvedMaskVBG:Sprite = new Sprite();		private var curvedMaskH:Sprite = new Sprite();		private var curvedMaskHBG:Sprite = new Sprite();				public function PDFScrollAreaBar(scrollArea:PDFScrollArea,scrollType:String,scrollbarWidth:Number,containerWidth:Number,containerHeight:Number,colourArray:Array) {			CursorManager.hideCursor();			this.buttonMode = true;			this.accelleration = scrollArea.accelleration;			/* Setup variables */			this.colourArray = colourArray;			this.scrollArea = scrollArea;			this.containerWidth = containerWidth;			this.containerHeight = containerHeight;			this.scrollbarWidth = scrollbarWidth;			this.scrollType = scrollType;						buttonPressTimer.addEventListener(TimerEvent.TIMER, moveButton);			tearDragTimer.addEventListener(TimerEvent.TIMER, moveTear);						setBounds();			drawObjects();			setEventListeners();			scrollArea.addChild(this);		}				/* Finds and sets the bounds of the scrollbar */		private function setBounds():void {			bounds.left = Math.round(scrollbarWidth + scrollbarWidth/6);			bounds.right = Math.round(containerWidth - scrollbarWidth - scrollbarWidth/3);			bounds.top = Math.round(scrollbarWidth + scrollbarWidth/6);			bounds.bottom = Math.round(containerHeight - scrollbarWidth - scrollbarWidth/3);		}				/* Draws the scrollbars */		private function drawBackground():void {			var colors:Array = [colourArray[2], colourArray[3]];			var alphas:Array = [1, 1];			var ratios:Array = [0x00, 0xFF];			var matr:Matrix = new Matrix();			switch(scrollType) {				case 'vertical':					matr.createGradientBox(scrollbarWidth/2, scrollbarWidth/2, 0, 0, 0);					scrollbarYbg.graphics.beginGradientFill(GradientType.LINEAR, colors,alphas,ratios,matr,SpreadMethod.REFLECT);					scrollbarYbg.graphics.drawRect(0,0, scrollbarWidth, containerHeight);					addChild(scrollbarYbg);					curvedMaskV.graphics.beginFill(0xFF000,1);					curvedMaskV.graphics.drawRoundRect(0-scrollbarWidth,0-scrollbarWidth,this.width+scrollbarWidth,this.height+scrollbarWidth,15);					curvedMaskVBG.graphics.beginFill(0xFF000,1);					curvedMaskVBG.graphics.drawRoundRect(0-scrollbarWidth,0-scrollbarWidth,this.width+scrollbarWidth,this.height+scrollbarWidth,15);					//addChild(curvedMaskVBG);					//scrollbarYbg.mask = curvedMaskVBG;					break;				case 'horizontal':					matr.createGradientBox(scrollbarWidth/2, scrollbarWidth/2, Math.PI / 2, 0, 0);					scrollbarXbg.graphics.beginGradientFill(GradientType.LINEAR, colors,alphas,ratios,matr,SpreadMethod.REFLECT);					scrollbarXbg.graphics.drawRect(0,0, containerWidth, scrollbarWidth);					addChild(scrollbarXbg);					curvedMaskH.graphics.beginFill(0xFF000,1);					curvedMaskH.graphics.drawRoundRect(0,0-scrollbarWidth,this.width+scrollbarWidth*2,this.height+scrollbarWidth,15);					curvedMaskHBG.graphics.beginFill(0xFF000,1);					curvedMaskHBG.graphics.drawRoundRect(0,0-scrollbarWidth,this.width+scrollbarWidth*2,this.height+scrollbarWidth,15);					addChild(curvedMaskHBG);					scrollbarXbg.mask = curvedMaskHBG;					break;			}		}				/* Sets the length of the tear */		private function setTearLength():void {			switch(scrollType) {				case 'vertical':					tearLength = containerHeight/scrollArea.innerObject.height * (containerHeight-scrollbarWidth*3);					if(tearLength > bounds.bottom-bounds.top) {						tearLength = bounds.bottom-bounds.top;					}					break;				case 'horizontal':					tearLength = containerWidth/scrollArea.innerObject.width * (containerWidth-scrollbarWidth*3);					if(tearLength > bounds.right-bounds.left) {						tearLength = bounds.right-bounds.left;					}					break;			}			if(tearLength < scrollbarWidth) {				tearLength = scrollbarWidth*2;			}		}				/* Draws the up and down buttons */		private function drawButtons():void {			switch(scrollType) {				case 'vertical':					//back button					backButton.graphics.beginFill(colourArray[0],0.6);					backButton.graphics.moveTo(0,0);					backButton.graphics.lineTo(0,scrollbarWidth*1.5);					backButton.graphics.curveTo(scrollbarWidth/2,scrollbarWidth*3/4,scrollbarWidth,scrollbarWidth*1.5);					backButton.graphics.lineTo(scrollbarWidth,0);					backButton.graphics.lineTo(0,0);					backButton.graphics.beginFill(colourArray[1],0.6);					backButton.graphics.moveTo(scrollbarWidth/2,scrollbarWidth/3);					backButton.graphics.lineTo(scrollbarWidth*.8,scrollbarWidth*.8);					backButton.graphics.lineTo(scrollbarWidth*.2,scrollbarWidth*.8);					//forward button					forwardButton.graphics.beginFill(colourArray[0],0.6);					forwardButton.graphics.moveTo(0,0);					forwardButton.graphics.curveTo(scrollbarWidth/2,scrollbarWidth/1.5,scrollbarWidth,0);					forwardButton.graphics.lineTo(scrollbarWidth,scrollbarWidth*1.5);					forwardButton.graphics.lineTo(0,scrollbarWidth*1.5);					forwardButton.graphics.lineTo(0,0);					forwardButton.graphics.beginFill(colourArray[1],0.6);					forwardButton.graphics.moveTo(scrollbarWidth/2,scrollbarWidth+scrollbarWidth*0.2);					forwardButton.graphics.lineTo(scrollbarWidth*.8,scrollbarWidth*.7);					forwardButton.graphics.lineTo(scrollbarWidth*.2,scrollbarWidth*.7);					forwardButton.y = containerHeight - scrollbarWidth*1.5;					//addChild(curvedMaskV);					//forwardButton.mask = curvedMaskV;					break;				case 'horizontal':					//back button					backButton.graphics.beginFill(colourArray[0],0.6);					backButton.graphics.moveTo(0,0);					backButton.graphics.lineTo(scrollbarWidth*1.5,0);					backButton.graphics.curveTo(scrollbarWidth*3/4,scrollbarWidth/2,scrollbarWidth*1.5,scrollbarWidth);					backButton.graphics.lineTo(0,scrollbarWidth);					backButton.graphics.lineTo(0,0);					backButton.graphics.beginFill(colourArray[1],0.6);					backButton.graphics.moveTo(scrollbarWidth/3,scrollbarWidth/2);					backButton.graphics.lineTo(scrollbarWidth*.8,scrollbarWidth*.8);					backButton.graphics.lineTo(scrollbarWidth*.8,scrollbarWidth*.2);					addChild(curvedMaskH);					backButton.mask = curvedMaskH;					//forward button					forwardButton.graphics.beginFill(colourArray[0],0.6);					forwardButton.graphics.moveTo(0,0);					forwardButton.graphics.curveTo(scrollbarWidth/1.5,scrollbarWidth/2,0,scrollbarWidth);					forwardButton.graphics.lineTo(scrollbarWidth*1.5,scrollbarWidth);					forwardButton.graphics.lineTo(scrollbarWidth*1.5,0);					forwardButton.graphics.lineTo(0,0);					forwardButton.graphics.beginFill(colourArray[1],0.6);					forwardButton.graphics.moveTo(scrollbarWidth+scrollbarWidth*0.2,scrollbarWidth/2);					forwardButton.graphics.lineTo(scrollbarWidth*.7,scrollbarWidth*.8);					forwardButton.graphics.lineTo(scrollbarWidth*.7,scrollbarWidth*.2);					forwardButton.x = containerWidth - scrollbarWidth*1.5;					break;			}			addChild(backButton);			addChild(forwardButton);		}				/* Draws the tear */		private function drawTear():void {			switch(scrollType) {				case 'vertical':					scrollTear.graphics.beginFill(colourArray[0],0.8);					scrollTear.graphics.drawRoundRect(1,1,scrollbarWidth-2,tearLength,scrollbarWidth-2);					scrollTear.y = bounds.top;										tearPastY = bounds.top;					tearCurrentY = bounds.top;										break;				case 'horizontal':					scrollTear.graphics.beginFill(colourArray[0],0.8);					scrollTear.graphics.drawRoundRect(1,1,tearLength,scrollbarWidth-2,scrollbarWidth-2);					scrollTear.x = bounds.left;										tearPastX = bounds.left;					tearCurrentX = bounds.left;										break;			}			addChild(scrollTear);		}				/* Puts the scrollbar in the right location */		private function setScrollbarPosition():void {			switch(scrollType) {				case 'horizontal':					this.y = containerHeight-scrollbarWidth;					break;				case 'vertical':					this.x = containerWidth-scrollbarWidth;					break;			}		}				/* Draws the objects */		private function drawObjects():void {			setTearLength();			drawBackground();			drawButtons();			drawTear();			buttonGlowFilter = new GlowFilter(colourArray[4], 0.8, 2, 2, 2, 1, true, false);			buttonFilters.push(buttonGlowFilter);			setScrollbarPosition();		}				//private function buttonPressTimer				/* Sets up the initial event listeners */		private function setEventListeners():void {			scrollbarXbg.addEventListener(MouseEvent.CLICK,scrollBarClicked);			scrollbarYbg.addEventListener(MouseEvent.CLICK,scrollBarClicked);			scrollTear.addEventListener(MouseEvent.MOUSE_DOWN,tearStartMove);			backButton.addEventListener(MouseEvent.MOUSE_DOWN,backButtonDown);			forwardButton.addEventListener(MouseEvent.MOUSE_DOWN,forwardButtonDown);		}				/* Does the scrolling of the tear and of the inner object */		private function scroll(newPosition:Number):void {			switch(scrollType) {				case 'horizontal':					if(newPosition < bounds.left + tearLength/2) {						if(scrollArea.useBounceBack) {							vx *= scrollArea.reverseAmount;						}						scrollTear.x = bounds.left;					} else if(newPosition > bounds.right - tearLength/2) {						if(scrollArea.useBounceBack) {							vx *= scrollArea.reverseAmount;						}						scrollTear.x = bounds.right - tearLength;					} else {						scrollTear.x = newPosition - tearLength/2;					}					var xpercent:Number = Math.round((scrollTear.x-bounds.left)/(bounds.right-bounds.left-tearLength)*100)/100;					scrollArea.innerObject.x = -1*(scrollArea.innerObject.width-containerWidth) * xpercent;					break;				case 'vertical':					if(newPosition < bounds.top + tearLength/2) {						if(scrollArea.useBounceBack) {							vy *= scrollArea.reverseAmount;						}						scrollTear.y = bounds.top;					} else if(newPosition > bounds.bottom - tearLength/2) {						if(scrollArea.useBounceBack) {							vy *= scrollArea.reverseAmount;						}						scrollTear.y = bounds.bottom - tearLength;					} else {						scrollTear.y = newPosition - tearLength/2;					}					var ypercent:Number = Math.round((scrollTear.y-bounds.top)/(bounds.bottom-bounds.top-tearLength)*100)/100;					scrollArea.innerObject.y = -1*(scrollArea.innerObject.height-containerHeight) * ypercent;					break;			}		}				public function scrollbarTearUpdate():void {			switch(scrollType) {				case 'horizontal':					var innerpercentx:Number = -1*(scrollArea.innerObject.x/(scrollArea.innerObject.width-containerWidth));					scrollTear.x = innerpercentx*(bounds.right-bounds.left-tearLength) + bounds.left;					break;				case 'vertical':					var innerpercenty:Number = -1*(scrollArea.innerObject.y/(scrollArea.innerObject.height-containerHeight));					scrollTear.y = innerpercenty*(bounds.bottom-bounds.top-tearLength) + bounds.top;					if(scrollTear.y < bounds.top) {						scrollTear.y = bounds.top;					} else if (scrollTear.y > bounds.bottom-scrollTear.height) {						scrollTear.y = bounds.bottom - scrollTear.height;					}					break;			}		}						/*----		EVENT LISTENERS		----*/				/* Checks when the background part of the scrollbar has been clicked */		private function scrollBarClicked(e:MouseEvent):void {			switch(scrollType) {				case 'horizontal':					scroll(e.localX);					break;				case 'vertical':					scroll(e.localY);					break;			}		}				/* Runs when the back button is pressed down */		private function backButtonDown(e:MouseEvent):void {			backButton.addEventListener(MouseEvent.MOUSE_UP,backButtonUp);			backButton.addEventListener(MouseEvent.MOUSE_OUT,backButtonUp);			buttonPressTimer.start();			buttonPressMovement = -1;		}				/* Runs when the back button is pressed up */		private function backButtonUp(e:MouseEvent):void {			buttonPressTimer.stop();		}				/* Runs when the forward button is pressed down */		private function forwardButtonDown(e:MouseEvent):void {			forwardButton.addEventListener(MouseEvent.MOUSE_UP,forwardButtonUp);			forwardButton.addEventListener(MouseEvent.MOUSE_OUT,forwardButtonUp);			buttonPressTimer.start();			buttonPressMovement = 1; 		}				/* Runs when the forward button is pressed up */		private function forwardButtonUp(e:MouseEvent):void {			buttonPressTimer.stop();		}				/* Runs when the buttons are pressed down */		private function moveButton(e:TimerEvent):void {			var speed:Number = 4;			switch(scrollType) {				case 'horizontal':					scroll(scrollTear.x + speed*buttonPressMovement + tearLength/2);					break;				case 'vertical':					scroll(scrollTear.y + speed*buttonPressMovement + tearLength/2);					break;			}		}				/* Runs when the tear is mouse_down */		private function tearStartMove(e:MouseEvent):void {			tearScrolling = true;			stage.addEventListener(MouseEvent.MOUSE_UP, tearStopMove);			tearDragTimer.start();		}				/* Stopping tear move on mouse_up on stage */		private function tearStopMove(e:MouseEvent):void {						try {				stage.removeEventListener(MouseEvent.MOUSE_UP, tearStopMove);			} catch (e:Error) {}			tearScrolling = false;			if(!scrollArea.useFriction) {				tearDragTimer.stop();			}		}				private function moveTear(e:TimerEvent):void {			if(tearScrolling) {				switch(scrollType) {					case 'horizontal':						scroll(mouseX);						tearPastX = tearCurrentX;						tearCurrentX = mouseX;						vx = tearCurrentX - tearPastX;						break;					case 'vertical':						scroll(mouseY);						tearPastY = tearCurrentY;						tearCurrentY = mouseY;						vy = tearCurrentY - tearPastY;						break;				}			} else {				//tearDragTimer.stop();				switch(scrollType) {					case 'horizontal':						vx *= accelleration;						if(Math.abs(vx) < 0.3) {							tearDragTimer.stop();							vx = 0;						} else {							scroll(scrollTear.x + tearLength/2 + vx);						}						break;					case 'vertical':						vy *= accelleration;						if(Math.abs(vy) < 0.3) {							tearDragTimer.stop();							vy = 0;						} else {							scroll(scrollTear.y + tearLength/2 + vy);						}						break;				}			}		}	}}