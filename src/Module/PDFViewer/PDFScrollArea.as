package Module.PDFViewer {	import flash.display.Sprite;	public class PDFScrollArea extends Sprite {		private var theWidth:Number;		private var theHeight:Number;		private var scrollType:String;		private var scrollbarWidth:Number;				private var colourArray:Array = new Array(0x333333,0xFFFFFF,0x999999,0xCCCCCC,0x2222FF);				private var scrollbarX:PDFScrollAreaBar;		private var scrollbarY:PDFScrollAreaBar;		private var scrollTouch:PDFScrollTouch;				private var contentArea:Sprite = new Sprite();		private var contentAreaMask:Sprite = new Sprite();				public var innerObject:*;		private var innerObjectWidth:Number = 0;		private var innerObjectHeight:Number = 0;				public var accelleration:Number = 0.95;				private var showScrollbars:Boolean = true;		private var useTouch:Boolean = false;		public var useFriction:Boolean = false;		public var useBounceBack:Boolean = false;				public var reverseAmount:Number = -0.2;		public function PDFScrollArea(innerObject:*,theWidth:Number,theHeight:Number,scrollbarWidth:Number = 30,scrollType:String = '',showScrollbars:Boolean = true,accelleration:Number = 0.95, useFriction:Boolean = false,useBounceBack:Boolean = false,useTouch:Boolean = false,colArr:Array = null) {			this.accelleration = accelleration;			this.showScrollbars = showScrollbars;			this.useTouch = useTouch;			this.useFriction = useFriction;			this.useBounceBack = useBounceBack;			if(colArr) {				colourArray = colArr;			}			this.innerObject = innerObject;			this.scrollbarWidth = scrollbarWidth;			this.theHeight = theHeight;			this.theWidth = theWidth;			this.scrollType = scrollType;			drawContentAreaMask();			this.scrollType = scrollType;			setScrollbars();		}				public function refresh(forced:Boolean,newWidth:Number,newHeight:Number):void {			this.graphics.clear();			scrollType = '';			if(newWidth < innerObject.width) {				scrollType = 'x';			}			if(newHeight < innerObject.height) {				if(scrollType == 'x') {					scrollType = 'both';				} else {					scrollType = 'y';				}			}			if(this.theWidth != newWidth || this.theHeight != theHeight || forced) {				this.theWidth = newWidth;				this.theHeight = newHeight;				setScrollbars();				drawContentAreaMask();			}			updateScrollbarX();			updateScrollbarY();		}				public function disableTouch():void {			useTouch = false;			refresh(true,this.theWidth,this.theHeight);		}				public function enableTouch():void {			useTouch = true;			refresh(true,this.theWidth,this.theHeight);		}				private function getInnerObject():* {			return innerObject;		}				private function drawContentAreaMask():void {			if(!this.contains(contentArea)) {				addChild(contentArea);			}			contentAreaMask.graphics.clear();			contentAreaMask.graphics.beginFill(0xFF0000,1);			var maskwidth:Number = theWidth;			var maskheight:Number = theHeight;			switch(scrollType) {				case 'x':					if(showScrollbars) {						maskheight -= scrollbarWidth;					}					break;				case 'y':					if(showScrollbars) {						maskwidth -= scrollbarWidth;					}					break;				case 'none':					break;				case 'multi':					break;				default:					if(showScrollbars) {						maskwidth -= scrollbarWidth;						maskheight -= scrollbarWidth;					}			}			contentAreaMask.graphics.drawRect(0,0,maskwidth,maskheight);			if(!this.contains(contentAreaMask)) {				addChild(contentAreaMask);			}			//Set up the inner object			if(!contentArea.contains(innerObject)) {				contentArea.addChild(innerObject);			}			this.innerObjectWidth = innerObject.width;			this.innerObjectHeight = innerObject.height;			contentArea.mask = contentAreaMask;		}				private function drawBottomRight():void {			this.graphics.beginFill(colourArray[0],1);			this.graphics.lineStyle(0,colourArray[0]);			this.graphics.drawRect(theWidth-scrollbarWidth,theHeight-scrollbarWidth,scrollbarWidth-1,scrollbarWidth-1);		}				private function setScrollbars():void {			if(showScrollbars) {				if(scrollbarX && this.contains(scrollbarX)) {					this.removeChild(scrollbarX);					scrollbarX = null;				}				if(scrollbarY && this.contains(scrollbarY)) {					this.removeChild(scrollbarY);					scrollbarY = null;				}				switch(scrollType) {					case 'x':						createXScroll();						break;					case 'y':						createYScroll();						break;					case 'none':						break;					default:						createBothScroll();						break;				}			}			if(this.scrollTouch && this.contains(this.scrollTouch)) {				this.removeChild(this.scrollTouch);				this.scrollTouch = null;			}			if(useTouch) { 				createTouchScroll(scrollType); 			}		}				private function createXScroll():void {			this.scrollbarX = new PDFScrollAreaBar(this,'horizontal',this.scrollbarWidth,this.theWidth,this.theHeight,colourArray);		}				private function createYScroll():void {			this.scrollbarY = new PDFScrollAreaBar(this,'vertical',this.scrollbarWidth,this.theWidth,this.theHeight,colourArray);		}				private function createBothScroll():void {			this.scrollbarX = new PDFScrollAreaBar(this,'horizontal',this.scrollbarWidth,this.theWidth-this.scrollbarWidth,this.theHeight,colourArray);			this.scrollbarY = new PDFScrollAreaBar(this,'vertical',this.scrollbarWidth,this.theWidth,this.theHeight-this.scrollbarWidth,colourArray);			drawBottomRight();		}				private function createTouchScroll(scrollType:String):void {			if(scrollType != 'none') {				this.scrollTouch = new PDFScrollTouch(this,contentAreaMask.width,contentAreaMask.height,scrollType,showScrollbars);			}		}				public function setBorder(borderWidth:Number,borderColor:uint):void {			this.graphics.beginFill(0xFFFFFF);			this.graphics.lineStyle(borderWidth,borderColor,1);			this.graphics.drawRect(-1,-1,this.theWidth+1,this.theHeight+1);			if(scrollType != 'x' && scrollType != 'y'  && scrollType != 'none') {				drawBottomRight();			}		}				public function updateScrollbarX():void {			if(scrollbarX) {				scrollbarX.scrollbarTearUpdate();			}			if(scrollbarY) {				scrollbarY.scrollbarTearUpdate();			}		}				public function updateScrollbarY():void {			if(scrollbarY) {				scrollbarY.scrollbarTearUpdate();			} else {							}		}	}}